---
phase: 01-foundation-database
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - lib/db/schema.ts
  - lib/db/client.ts
  - lib/env.ts
  - drizzle.config.ts
  - app/api/health/route.ts
  - .env.local
  - package.json
autonomous: false
user_setup:
  - service: neon
    why: "Postgres database for persistent data storage"
    env_vars:
      - name: DATABASE_URL
        source: "Neon Console -> Project -> Connection Details -> Connection string (pooled)"
    dashboard_config:
      - task: "Create a Neon project (free tier)"
        location: "https://console.neon.tech -> New Project"
  - service: vercel
    why: "Deployment hosting with public URL"
    env_vars: []
    dashboard_config:
      - task: "Import GitHub repo and add DATABASE_URL env var"
        location: "https://vercel.com/new -> Import Git Repository"

must_haves:
  truths:
    - "Neon database is connected and stores at least one test record"
    - "App is deployed to Vercel with a public URL"
    - "Database schema exists with training_jobs table"
  artifacts:
    - path: "lib/db/schema.ts"
      provides: "Drizzle schema with trainingJobs table"
      contains: "pgTable"
    - path: "lib/db/client.ts"
      provides: "Database client using Neon serverless driver"
      contains: "drizzle"
    - path: "lib/env.ts"
      provides: "Zod-validated environment variables"
      contains: "DATABASE_URL"
    - path: "drizzle.config.ts"
      provides: "Drizzle Kit configuration for migrations"
      contains: "dialect.*postgresql"
    - path: "app/api/health/route.ts"
      provides: "Health check endpoint that queries database"
      exports: ["GET"]
  key_links:
    - from: "lib/db/client.ts"
      to: "lib/env.ts"
      via: "imports validated DATABASE_URL"
      pattern: "env.DATABASE_URL"
    - from: "lib/db/client.ts"
      to: "lib/db/schema.ts"
      via: "imports schema for typed queries"
      pattern: "import.*schema"
    - from: "app/api/health/route.ts"
      to: "lib/db/client.ts"
      via: "imports db client to verify connection"
      pattern: "import.*db"
---

<objective>
Set up Neon Postgres database with Drizzle ORM, push the initial schema, verify with a health check endpoint, and deploy to Vercel.

Purpose: Establish the persistence layer and production deployment so the app is live and database-connected from day one.
Output: Deployed app at a public Vercel URL with working Neon database storing a test record.
</objective>

<execution_context>
@/home/wraith/.claude/get-shit-done/workflows/execute-plan.md
@/home/wraith/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-database/01-RESEARCH.md
@.planning/phases/01-foundation-database/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Set up Neon database connection with Drizzle ORM and initial schema</name>
  <files>lib/db/schema.ts, lib/db/client.ts, lib/env.ts, drizzle.config.ts, app/api/health/route.ts, .env.local, package.json</files>
  <action>
1. **Install database dependencies:**
   ```bash
   pnpm add @neondatabase/serverless drizzle-orm zod
   pnpm add -D drizzle-kit
   ```

2. **Create lib/env.ts** -- Zod validation for environment variables:
   ```typescript
   import { z } from "zod"

   const envSchema = z.object({
     DATABASE_URL: z.string().min(1, "DATABASE_URL is required"),
     NODE_ENV: z.enum(["development", "production", "test"]).default("development"),
   })

   // Only validate on server side
   export const env = envSchema.parse(process.env)
   ```

3. **Create lib/db/client.ts** -- Drizzle client with Neon serverless:
   ```typescript
   import { drizzle } from "drizzle-orm/neon-http"
   import { neon } from "@neondatabase/serverless"
   import * as schema from "./schema"

   // Use dynamic import of env to avoid client-side validation
   const sql = neon(process.env.DATABASE_URL!)
   export const db = drizzle(sql, { schema })
   ```
   NOTE: Use process.env.DATABASE_URL! directly in client.ts rather than importing env.ts, because Drizzle config also needs the URL and importing env.ts there causes issues. The Zod validation in env.ts is for application code that wants strict validation.

4. **Create lib/db/schema.ts** -- Initial schema with training_jobs table:
   ```typescript
   import { pgTable, serial, text, timestamp, varchar, integer, real } from "drizzle-orm/pg-core"

   export const trainingJobs = pgTable("training_jobs", {
     id: serial("id").primaryKey(),
     name: varchar("name", { length: 255 }).notNull(),
     status: text("status", { enum: ["queued", "running", "complete", "failed"] }).notNull().default("queued"),
     modelName: varchar("model_name", { length: 255 }).notNull(),
     epochs: integer("epochs").notNull().default(10),
     learningRate: real("learning_rate").notNull().default(0.001),
     createdAt: timestamp("created_at").defaultNow().notNull(),
     updatedAt: timestamp("updated_at").defaultNow().notNull(),
   })
   ```

5. **Create drizzle.config.ts** at project root:
   ```typescript
   import { defineConfig } from "drizzle-kit"

   export default defineConfig({
     schema: "./lib/db/schema.ts",
     out: "./lib/db/migrations",
     dialect: "postgresql",
     dbCredentials: {
       url: process.env.DATABASE_URL!,
     },
   })
   ```

6. **Create .env.local** with placeholder:
   ```
   DATABASE_URL="postgresql://placeholder:placeholder@placeholder.neon.tech/neondb?sslmode=require"
   ```
   (User will replace with real Neon connection string)

7. **Create app/api/health/route.ts** -- Health check that verifies DB connection:
   ```typescript
   import { NextResponse } from "next/server"
   import { db } from "@/lib/db/client"
   import { trainingJobs } from "@/lib/db/schema"
   import { sql } from "drizzle-orm"

   export async function GET() {
     try {
       // Simple query to verify connection
       const result = await db.select({ count: sql<number>`count(*)` }).from(trainingJobs)
       return NextResponse.json({
         status: "healthy",
         database: "connected",
         trainingJobCount: result[0]?.count ?? 0,
         timestamp: new Date().toISOString(),
       })
     } catch (error) {
       return NextResponse.json(
         { status: "unhealthy", database: "disconnected", error: String(error) },
         { status: 500 }
       )
     }
   }
   ```

8. **Add scripts to package.json:**
   ```json
   "db:push": "drizzle-kit push",
   "db:studio": "drizzle-kit studio",
   "db:generate": "drizzle-kit generate"
   ```

After the user provides their Neon DATABASE_URL:
- Update .env.local with the real connection string
- Run `pnpm db:push` to create the training_jobs table in Neon
- Insert a test record via the Drizzle client or raw SQL to verify
- Hit /api/health to confirm connection
  </action>
  <verify>
- All files exist: lib/db/schema.ts, lib/db/client.ts, lib/env.ts, drizzle.config.ts, app/api/health/route.ts
- `pnpm dev` still runs without errors (even with placeholder DB URL, the app should load -- DB is only hit on /api/health)
- After user provides real DATABASE_URL: `pnpm db:push` succeeds, `curl http://localhost:3000/api/health` returns {"status":"healthy","database":"connected"}
  </verify>
  <done>Database layer is configured: Drizzle schema defines training_jobs table, Neon client connects via serverless driver, health endpoint verifies connection. Schema is pushed to Neon and at least one test record exists.</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 2: User provides Neon DATABASE_URL and verifies database connection</name>
  <files>.env.local</files>
  <action>
CHECKPOINT: User must provide a real Neon connection string.

What was built: Database integration layer with Drizzle ORM, Neon serverless driver, training_jobs schema, and /api/health endpoint. Everything is wired but needs a real Neon connection string to activate.

Steps for user:
1. Create a free Neon project at https://console.neon.tech (click "New Project")
2. Copy the connection string from the dashboard (Connection Details section)
3. Paste it into .env.local replacing the placeholder: DATABASE_URL="your-neon-connection-string"
4. Claude will then run: `pnpm db:push` to create the table
5. Claude will insert a test record and hit /api/health
6. Verify: visit http://localhost:3000/api/health -- should show {"status":"healthy","database":"connected","trainingJobCount":1}

Resume signal: Paste your Neon DATABASE_URL or type "done" if you've already added it to .env.local
  </action>
  <verify>
- .env.local contains a real Neon connection string (not placeholder)
- `pnpm db:push` succeeds without errors
- `curl http://localhost:3000/api/health` returns {"status":"healthy","database":"connected","trainingJobCount":1}
  </verify>
  <done>Neon database is connected with real credentials, training_jobs table exists, and at least one test record has been inserted.</done>
</task>

<task type="auto">
  <name>Task 3: Deploy to Vercel with public URL</name>
  <files>package.json</files>
  <action>
1. **Ensure the project is pushed to GitHub** (it should already be a git repo):
   ```bash
   git add .
   git commit -m "feat: foundation setup with theming, navigation, and database"
   git push origin main
   ```
   If no remote is set, the user needs to create a GitHub repo and add it. Check with `git remote -v`.

2. **Deploy using Vercel CLI:**
   ```bash
   pnpm dlx vercel --yes
   ```
   This will:
   - Auto-detect Next.js framework
   - Create a Vercel project
   - Deploy to a preview URL

3. **Set the DATABASE_URL environment variable on Vercel:**
   ```bash
   pnpm dlx vercel env add DATABASE_URL production
   ```
   (Paste the same Neon connection string when prompted)

4. **Redeploy to production:**
   ```bash
   pnpm dlx vercel --prod --yes
   ```

5. **Verify deployment:**
   - Get the production URL from Vercel output
   - `curl https://YOUR-URL.vercel.app/api/health` should return healthy status
   - Visit the URL in browser: sidebar navigation and theming should work

If Vercel CLI auth fails, create a checkpoint for the user to authenticate. But try CLI first.

NOTE: If there is no GitHub remote or the user prefers manual Vercel setup, provide instructions for the Vercel dashboard import flow instead.
  </action>
  <verify>
- `curl https://YOUR-VERCEL-URL.vercel.app/api/health` returns {"status":"healthy","database":"connected"}
- Visiting the Vercel URL in browser shows the app with sidebar, Liquid AI theming, and dark mode toggle
- All 3 routes work on the deployed version
  </verify>
  <done>App is deployed to Vercel with a shareable public URL. Database is connected in production. All navigation, theming, and dark mode work on the deployed version.</done>
</task>

</tasks>

<verification>
1. `curl https://YOUR-VERCEL-URL.vercel.app/api/health` returns healthy with trainingJobCount >= 1
2. Deployed app shows sidebar with Dashboard, Training, Deployments navigation
3. Deployed app uses Liquid AI purple/blue colors
4. Dark mode toggle works on deployed version
5. Neon database has training_jobs table with at least one test record
</verification>

<success_criteria>
- FNDN-04: App deployed to Vercel with shareable public URL accessible from any browser
- FNDN-05: Neon Postgres connected, training_jobs table exists with at least one record, /api/health confirms connection
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-database/01-02-SUMMARY.md`
</output>
