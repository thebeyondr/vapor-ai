---
phase: 05-training-monitor
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - app/(dashboard)/training/jobs/actions.ts
  - app/(dashboard)/training/jobs/page.tsx
  - app/api/training/[id]/metrics/route.ts
  - lib/db/queries.ts
  - app/layout.tsx
autonomous: true

must_haves:
  truths:
    - "Server Action can start a queued job (transition queued to running)"
    - "Server Action can simulate one training step and persist metrics to database"
    - "Server Action can mark a job as failed"
    - "API route returns job data and recent metrics for a given job ID"
    - "Jobs list page shows all training jobs with status badges and links to monitor"
    - "Sonner Toaster is mounted in the app layout"
  artifacts:
    - path: "app/(dashboard)/training/jobs/actions.ts"
      provides: "Server Actions for training operations"
      exports: ["startTrainingJob", "simulateTrainingStep", "failTrainingJob"]
    - path: "app/(dashboard)/training/jobs/page.tsx"
      provides: "Training jobs list page"
    - path: "app/api/training/[id]/metrics/route.ts"
      provides: "GET endpoint for job metrics"
      exports: ["GET"]
    - path: "lib/db/queries.ts"
      provides: "getTrainingJob and getTrainingMetrics query functions"
    - path: "app/layout.tsx"
      provides: "Sonner Toaster component mounted"
      contains: "Toaster"
  key_links:
    - from: "app/(dashboard)/training/jobs/actions.ts"
      to: "lib/services/training-simulator.ts"
      via: "import TrainingSimulator"
      pattern: "TrainingSimulator"
    - from: "app/(dashboard)/training/jobs/actions.ts"
      to: "lib/db/schema.ts"
      via: "import trainingMetrics"
      pattern: "trainingMetrics"
    - from: "app/api/training/[id]/metrics/route.ts"
      to: "lib/db/queries.ts"
      via: "import query functions"
      pattern: "getTrainingJob|getTrainingMetrics"
    - from: "app/(dashboard)/training/jobs/page.tsx"
      to: "lib/db/queries.ts"
      via: "Server Component data fetching"
      pattern: "getRecentJobs|getAllJobs"
---

<objective>
Build the data layer for training operations: Server Actions to start/simulate/fail training jobs, API route for polling metrics, jobs list page, and Sonner toaster setup.

Purpose: All the server-side plumbing needed for the training monitor UI — actions to drive state transitions, an API for client polling, and a jobs listing to navigate between training runs.
Output: Functional Server Actions, metrics API endpoint, jobs list page, and Sonner ready for toasts.
</objective>

<execution_context>
@/home/wraith/.claude/get-shit-done/workflows/execute-plan.md
@/home/wraith/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-training-monitor/05-RESEARCH.md
@.planning/phases/05-training-monitor/05-01-SUMMARY.md
@lib/db/schema.ts
@lib/db/queries.ts
@lib/db/client.ts
@app/(dashboard)/training/configure/actions.ts
@app/(dashboard)/components/status-badge.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Server Actions and metrics API route</name>
  <files>app/(dashboard)/training/jobs/actions.ts, app/api/training/[id]/metrics/route.ts, lib/db/queries.ts</files>
  <action>
    1. Add query functions to `lib/db/queries.ts`:
       - `getTrainingJob(id: number)` — fetch single job by ID using `eq(trainingJobs.id, id)`, wrapped in React `cache()`
       - `getTrainingMetrics(jobId: number, limit = 200)` — fetch metrics for a job, ordered by step ASC, with limit. Use `db.select().from(trainingMetrics).where(eq(trainingMetrics.jobId, jobId)).orderBy(asc(trainingMetrics.step)).limit(limit)`. Wrapped in React `cache()`.
       - `getAllJobs()` — fetch all training jobs ordered by createdAt DESC. Wrapped in React `cache()`.
       - Import `asc` from drizzle-orm alongside existing imports.
       - Import `trainingMetrics` from schema.

    2. Create `app/(dashboard)/training/jobs/actions.ts` with "use server" directive:

       **`startTrainingJob(jobId: number)`:**
       - Fetch job by ID
       - Validate status is "queued" (return error if not)
       - Update status to "running" and updatedAt to new Date()
       - Revalidate "/training/jobs" and "/training/jobs/{jobId}" and "/"
       - Return `{ success: true }` or `{ success: false, error: string }`

       **`simulateTrainingStep(jobId: number)`:**
       - Fetch job by ID, validate status is "running"
       - Count existing metrics for this job: `db.select({ count: count() }).from(trainingMetrics).where(eq(trainingMetrics.jobId, jobId))`
       - Calculate totalSteps as `job.epochs * 100` (100 steps per epoch)
       - Calculate nextStep as `currentCount + 1`
       - If nextStep > totalSteps, transition job to "complete", revalidate paths, return `{ success: true, complete: true, progress: 1 }`
       - Otherwise, instantiate TrainingSimulator and generate one metric point
       - Insert metric into trainingMetrics table (jobId, epoch, step, loss, accuracy, learningRate from job)
       - Return `{ success: true, complete: false, progress: nextStep / totalSteps }`
       - Wrap in try/catch — on error, update job to "failed", return error

       **`failTrainingJob(jobId: number)`:**
       - Fetch job by ID, validate status is "running" or "queued"
       - Update status to "failed" and updatedAt
       - Revalidate paths
       - Return `{ success: true }` or `{ success: false, error: string }`

       Import TrainingSimulator from `@/lib/services/training-simulator`.
       Import count from drizzle-orm.
       Use error-as-data pattern (return objects, don't throw).

    3. Create `app/api/training/[id]/metrics/route.ts`:
       - Export async function GET with NextRequest and params `{ id: string }`
       - NOTE: In Next.js 15+, params is a Promise. Use `const { id } = await params` pattern.
       - Parse id as integer, return 400 if NaN
       - Fetch job using `db.select().from(trainingJobs).where(eq(trainingJobs.id, jobId))` (direct query, not cached — polling endpoint needs fresh data)
       - If no job, return 404
       - Fetch metrics directly: `db.select().from(trainingMetrics).where(eq(trainingMetrics.jobId, jobId)).orderBy(asc(trainingMetrics.step)).limit(200)`
       - Return `Response.json({ job, metrics })` with metrics mapped to `{ step, loss, accuracy, epoch }`
       - Import from drizzle-orm: eq, asc
       - Import db from `@/lib/db/client`
       - Import schema tables from `@/lib/db/schema`
  </action>
  <verify>
    - `pnpm build` compiles without errors
    - `app/(dashboard)/training/jobs/actions.ts` exports startTrainingJob, simulateTrainingStep, failTrainingJob
    - `app/api/training/[id]/metrics/route.ts` exports GET
    - `lib/db/queries.ts` exports getTrainingJob, getTrainingMetrics, getAllJobs
  </verify>
  <done>
    - Server Actions handle all training state transitions (start, simulate step, fail)
    - API route returns job + metrics for client polling
    - Query functions added for job/metrics retrieval
  </done>
</task>

<task type="auto">
  <name>Task 2: Create training jobs list page and mount Sonner Toaster</name>
  <files>app/(dashboard)/training/jobs/page.tsx, app/layout.tsx</files>
  <action>
    1. Create `app/(dashboard)/training/jobs/page.tsx` as a Server Component:
       - Fetch all jobs using getAllJobs() from `@/lib/db/queries`
       - Display page title "Training Jobs" with subtitle
       - If no jobs, show empty state with link to /training/configure
       - Render jobs as a list/table using Card components:
         - Each job card shows: name, model name, status (using StatusBadge from `@/app/(dashboard)/components/status-badge`), epochs, learning rate, created date (format with date-fns `formatDistanceToNow`)
         - Each job card links to `/training/jobs/${job.id}` for the monitor view
         - Show a "Start Training" button for queued jobs (this will be a client component island)
       - Create a small client component `JobActions` in the same file (or inline) that:
         - For "queued" status: shows "Start" button that calls startTrainingJob action
         - For "running" status: shows "Stop" button that calls failTrainingJob action
         - For "complete"/"failed": shows "View" link to monitor page
         - Uses toast from sonner for success/error feedback
         - Uses useTransition for pending state

    2. Mount Sonner `<Toaster />` in `app/layout.tsx`:
       - Import `Toaster` from `sonner`
       - Add `<Toaster richColors position="top-right" />` inside the body, after children
       - Position it after the ThemeProvider but inside body
       - Use `richColors` prop for semantic coloring (green success, red error)
       - Add `toastOptions` with className for consistent styling if needed

    Note: The jobs list page serves as the navigation hub for all training jobs. Users land here from the dashboard or after creating a job. From here they can start jobs and navigate to individual monitors.
  </action>
  <verify>
    - `pnpm build` compiles without errors
    - `/training/jobs` route exists and renders
    - `app/layout.tsx` contains Sonner Toaster component
    - Jobs list shows StatusBadge for each job
    - JobActions component renders appropriate buttons per status
  </verify>
  <done>
    - Training jobs list page displays all jobs with status, actions, and links to monitor
    - Sonner toaster is mounted globally for toast notifications
    - Users can start queued jobs and stop running jobs from the list
  </done>
</task>

</tasks>

<verification>
1. `pnpm build` passes with no errors
2. `/training/jobs` route renders job list
3. Server Actions compile and are properly typed
4. API route at `/api/training/[id]/metrics` returns JSON
5. Sonner Toaster renders in the app shell
6. StatusBadge reused from existing component
</verification>

<success_criteria>
All server-side training operations work (start, simulate, fail), API route serves metrics for polling, jobs list page lets users manage training runs, and Sonner is ready for notifications.
</success_criteria>

<output>
After completion, create `.planning/phases/05-training-monitor/05-02-SUMMARY.md`
</output>
