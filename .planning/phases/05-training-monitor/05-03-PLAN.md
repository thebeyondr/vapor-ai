---
phase: 05-training-monitor
plan: 03
type: execute
wave: 3
depends_on: ["05-01", "05-02"]
files_modified:
  - app/(dashboard)/training/jobs/[id]/page.tsx
  - app/(dashboard)/training/jobs/[id]/components/loss-chart.tsx
  - app/(dashboard)/training/jobs/[id]/components/training-stats.tsx
  - app/(dashboard)/training/jobs/[id]/components/training-monitor.tsx
autonomous: true

must_haves:
  truths:
    - "User sees loss curve updating in real-time with realistic exponential decay"
    - "Training monitor displays epoch progress, ETA, and overall progress bar"
    - "Training job transitions through queued to running to complete/failed visually"
    - "Failed jobs show red status badge and trigger error toast"
    - "Completed jobs show green status badge and trigger success toast"
    - "Multiple training jobs can be monitored independently"
  artifacts:
    - path: "app/(dashboard)/training/jobs/[id]/page.tsx"
      provides: "Training monitor page route"
    - path: "app/(dashboard)/training/jobs/[id]/components/loss-chart.tsx"
      provides: "Recharts loss curve visualization"
      contains: "LineChart"
    - path: "app/(dashboard)/training/jobs/[id]/components/training-stats.tsx"
      provides: "Epoch count, ETA, progress bar display"
      contains: "Progress"
    - path: "app/(dashboard)/training/jobs/[id]/components/training-monitor.tsx"
      provides: "Client component orchestrating polling, chart updates, and toasts"
      contains: "useInterval"
  key_links:
    - from: "app/(dashboard)/training/jobs/[id]/components/training-monitor.tsx"
      to: "/api/training/[id]/metrics"
      via: "fetch in useInterval callback"
      pattern: "fetch.*api/training"
    - from: "app/(dashboard)/training/jobs/[id]/components/training-monitor.tsx"
      to: "app/(dashboard)/training/jobs/actions.ts"
      via: "import simulateTrainingStep"
      pattern: "simulateTrainingStep"
    - from: "app/(dashboard)/training/jobs/[id]/components/training-monitor.tsx"
      to: "lib/hooks/use-interval.ts"
      via: "import useInterval"
      pattern: "useInterval"
    - from: "app/(dashboard)/training/jobs/[id]/components/loss-chart.tsx"
      to: "recharts"
      via: "import LineChart components"
      pattern: "LineChart.*recharts"
    - from: "app/(dashboard)/training/jobs/[id]/components/training-stats.tsx"
      to: "components/ui/progress.tsx"
      via: "import Progress"
      pattern: "Progress"
---

<objective>
Build the training monitor page — the "wow feature" — with live-updating loss curves via Recharts, epoch/ETA/progress display, automatic training simulation via polling, and toast notifications for status transitions.

Purpose: This is the centerpiece of the Vapor demo. Users watch a training job progress in real-time with a smooth loss curve, clear metrics, and satisfying status transitions. It proves frontend craft in handling real-time data visualization.
Output: Complete training monitor page at `/training/jobs/[id]` with live chart, stats, and notifications.
</objective>

<execution_context>
@/home/wraith/.claude/get-shit-done/workflows/execute-plan.md
@/home/wraith/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-training-monitor/05-RESEARCH.md
@.planning/phases/05-training-monitor/05-01-SUMMARY.md
@.planning/phases/05-training-monitor/05-02-SUMMARY.md
@lib/services/training-simulator.ts
@lib/hooks/use-interval.ts
@lib/db/schema.ts
@app/(dashboard)/training/jobs/actions.ts
@app/api/training/[id]/metrics/route.ts
@app/(dashboard)/components/status-badge.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create loss chart and training stats components</name>
  <files>app/(dashboard)/training/jobs/[id]/components/loss-chart.tsx, app/(dashboard)/training/jobs/[id]/components/training-stats.tsx</files>
  <action>
    1. Create `app/(dashboard)/training/jobs/[id]/components/loss-chart.tsx`:
       - Mark "use client" (Recharts requires client rendering)
       - Import from recharts: LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, ResponsiveContainer, Area, AreaChart
       - Use AreaChart (not LineChart) for a more visually impactful loss curve with gradient fill
       - Props: `{ data: Array<{ step: number; loss: number; accuracy?: number }> }`
       - Wrap in ResponsiveContainer with width="100%" height={350}
       - XAxis: dataKey="step", label "Training Step"
       - YAxis: domain={[0, 'dataMax + 0.5']} for stable axis with padding, label "Loss"
       - CartesianGrid with strokeDasharray="3 3" and low opacity
       - Tooltip: format loss to 4 decimal places, label as "Step {n}"
       - Area/Line for loss: stroke color using CSS variable `hsl(var(--chart-1))`, strokeWidth 2, dot={false}, fill with gradient
       - Add a defs block with linearGradient for the area fill (fade from chart color to transparent)
       - Use animationDuration={300} for smooth real-time updates
       - If data is empty, show a centered "Waiting for training data..." message in muted text
       - Wrap in a Card with CardHeader (title "Loss Curve") and CardContent

    2. Create `app/(dashboard)/training/jobs/[id]/components/training-stats.tsx`:
       - Mark "use client"
       - Import Progress from `@/components/ui/progress`
       - Import Card, CardContent, CardHeader, CardTitle from `@/components/ui/card`
       - Props: `{ currentEpoch: number; totalEpochs: number; currentStep: number; totalSteps: number; latestLoss: number | null; latestAccuracy: number | null; status: string; startedAt?: Date | null }`
       - Calculate progress percentage: `(currentStep / totalSteps) * 100`
       - Calculate ETA: use elapsed time and progress to estimate remaining
         - `const elapsed = Date.now() - (startedAt?.getTime() || Date.now())`
         - `const estimatedTotal = progress > 0 ? elapsed / (progress / 100) : 0`
         - `const remaining = Math.max(0, estimatedTotal - elapsed)`
         - Format with simple helper: seconds -> "Xs", minutes -> "Xm Ys", hours -> "Xh Ym"
       - Render in a Card with grid layout (2x2 on desktop, 1 col on mobile):
         - Epoch: "{currentEpoch} / {totalEpochs}" with label
         - Steps: "{currentStep} / {totalSteps}" with label
         - Loss: latest loss formatted to 4 decimal places (or "--" if null)
         - Accuracy: latest accuracy as percentage (or "--" if null)
       - Below the grid: full-width Progress bar with `value={progress}`
       - Below progress bar: text showing "X% complete" and "ETA: Xm Ys" (or "Calculating..." if progress is 0)
       - When status is "complete": show "Training Complete" in green text instead of ETA
       - When status is "failed": show "Training Failed" in red text instead of ETA
  </action>
  <verify>
    - `pnpm build` compiles without errors
    - Both components exist at correct paths
    - LossChart imports from recharts
    - TrainingStats imports Progress from ShadCN
  </verify>
  <done>
    - LossChart renders AreaChart with gradient fill, proper axes, and tooltip
    - TrainingStats shows epoch/step/loss/accuracy grid with progress bar and ETA
    - Both components handle empty/null states gracefully
  </done>
</task>

<task type="auto">
  <name>Task 2: Build training monitor client component and page route</name>
  <files>app/(dashboard)/training/jobs/[id]/components/training-monitor.tsx, app/(dashboard)/training/jobs/[id]/page.tsx</files>
  <action>
    1. Create `app/(dashboard)/training/jobs/[id]/components/training-monitor.tsx`:
       - Mark "use client"
       - Import useInterval from `@/lib/hooks/use-interval`
       - Import LossChart and TrainingStats from sibling components
       - Import StatusBadge from `@/app/(dashboard)/components/status-badge`
       - Import simulateTrainingStep, failTrainingJob from `../actions` (relative to jobs dir — need correct path based on file location, which is `../../actions` since we're in [id]/components/)
       - Import Button from `@/components/ui/button`
       - Import toast from sonner
       - Import useState, useCallback, useRef from react

       - Props interface:
         ```
         interface TrainingMonitorProps {
           job: { id: number; name: string; modelName: string; epochs: number; learningRate: number; batchSize: number; status: string; createdAt: Date; updatedAt: Date };
           initialMetrics: Array<{ step: number; loss: number; accuracy: number | null; epoch: number }>;
         }
         ```

       - State:
         - `status` (initialized from job.status)
         - `metrics` (initialized from initialMetrics)
         - `isSimulating` (boolean, starts false)

       - Derive computed values:
         - `totalSteps = job.epochs * 100`
         - `currentStep = metrics[metrics.length - 1]?.step || 0`
         - `currentEpoch = metrics[metrics.length - 1]?.epoch || 0`
         - `progress = (currentStep / totalSteps) * 100`
         - `latestLoss = metrics[metrics.length - 1]?.loss ?? null`
         - `latestAccuracy = metrics[metrics.length - 1]?.accuracy ?? null`
         - `isActive = status === "running"`

       - Polling logic with useInterval:
         - Delay: `isActive ? 1500 : null` (1.5 second intervals when running, paused otherwise)
         - Callback function (wrapped in useCallback):
           a. Call `simulateTrainingStep(job.id)` Server Action
           b. If result.success && result.complete:
              - Set status to "complete"
              - toast.success("Training Complete!", { description: `${job.name} finished successfully` })
           c. If result.success && !result.complete:
              - Fetch updated metrics from `/api/training/${job.id}/metrics`
              - Update metrics state with response data
           d. If !result.success:
              - Set status to "failed"
              - toast.error("Training Failed", { description: result.error })

       - "Start Training" button handler (for queued jobs):
         - Import startTrainingJob from actions
         - Call startTrainingJob(job.id)
         - If success: set status to "running", toast.success("Training started")
         - If error: toast.error with error message

       - "Stop Training" button handler (for running jobs):
         - Call failTrainingJob(job.id)
         - Set status to "failed"
         - toast.error("Training stopped", { description: "Job was manually stopped" })

       - Render layout:
         - Header row: StatusBadge + job actions (Start/Stop buttons depending on status)
         - LossChart with metrics data (map to { step, loss, accuracy })
         - TrainingStats with all computed values
         - When status is "queued": show prominent "Start Training" button with Play icon
         - When status is "running": show "Stop Training" button (destructive variant) with Square icon
         - When status is "complete" or "failed": no action buttons, just status display

       - Import icons: Play, Square from lucide-react

    2. Create `app/(dashboard)/training/jobs/[id]/page.tsx` as Server Component:
       - Import db from `@/lib/db/client`
       - Import trainingJobs, trainingMetrics from `@/lib/db/schema`
       - Import eq, asc from drizzle-orm
       - Import notFound from next/navigation
       - Import TrainingMonitor from ./components/training-monitor
       - Import Link from next/link and ArrowLeft from lucide-react

       - NOTE: In Next.js 15+, params is a Promise. Use `const { id } = await params` pattern.
       - Parse job ID from params (parseInt)
       - Fetch job directly (not cached — needs fresh data): `db.select().from(trainingJobs).where(eq(trainingJobs.id, jobId))`
       - If no job, call notFound()
       - Fetch initial metrics: `db.select().from(trainingMetrics).where(eq(trainingMetrics.jobId, jobId)).orderBy(asc(trainingMetrics.step)).limit(200)`

       - Render:
         - Back link to /training/jobs with ArrowLeft icon
         - Page title: job.name
         - Subtitle: "{job.modelName} - {job.epochs} epochs - LR {job.learningRate}"
         - TrainingMonitor component with job and initialMetrics props

       - Type the params correctly for Next.js 15: `{ params: Promise<{ id: string }> }`
  </action>
  <verify>
    - `pnpm build` compiles without errors
    - `/training/jobs/[id]` route exists
    - TrainingMonitor component uses useInterval for polling
    - TrainingMonitor calls simulateTrainingStep Server Action
    - LossChart receives metrics data
    - TrainingStats receives computed values
    - Toast notifications fire on status transitions
  </verify>
  <done>
    - Training monitor page renders at /training/jobs/{id}
    - Loss curve updates in real-time every 1.5 seconds during training
    - Users can start queued jobs and stop running jobs
    - Status transitions trigger toast notifications (success on complete, error on fail)
    - Progress bar, epoch count, and ETA update live
    - Multiple jobs can be monitored independently (each has own state)
  </done>
</task>

</tasks>

<verification>
1. `pnpm build` passes with no errors
2. Navigate to `/training/jobs/{id}` — monitor page renders
3. Loss chart displays with proper axes and gradient fill
4. Training stats show epoch, step, loss, accuracy in grid layout
5. Progress bar shows overall completion percentage
6. Starting a queued job triggers simulation and live updates
7. Completing training shows success toast and green status
8. Failing/stopping training shows error toast and red status
9. Back navigation to jobs list works
</verification>

<success_criteria>
The training monitor is the "wow feature" — a user can navigate to a training job, start it, and watch loss curves update in real-time with smooth animations, clear progress indicators, and satisfying status transitions with toast notifications. The experience should feel like watching a real training run.
</success_criteria>

<output>
After completion, create `.planning/phases/05-training-monitor/05-03-SUMMARY.md`
</output>
