---
phase: 06-deployments
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/db/schema.ts
  - lib/db/queries.ts
  - lib/services/inference-simulator.ts
  - app/(dashboard)/deployments/actions.ts
  - app/(dashboard)/training/jobs/job-actions.tsx
  - app/(dashboard)/training/jobs/[id]/page.tsx
autonomous: true

must_haves:
  truths:
    - "User can deploy a completed training job from the training jobs list or monitor"
    - "Deployment records are persisted to Neon database with version, status, and job reference"
    - "Inference metrics can be generated on-demand for any active deployment"
  artifacts:
    - path: "lib/db/schema.ts"
      provides: "deployments table with versioning and job reference"
      contains: "deployments"
    - path: "lib/services/inference-simulator.ts"
      provides: "Realistic inference metric generation"
      exports: ["generateInferenceMetrics"]
    - path: "app/(dashboard)/deployments/actions.ts"
      provides: "Deploy Server Action"
      exports: ["deployTrainingJob"]
    - path: "app/(dashboard)/training/jobs/job-actions.tsx"
      provides: "Deploy button for completed jobs"
      contains: "Deploy"
  key_links:
    - from: "app/(dashboard)/training/jobs/job-actions.tsx"
      to: "app/(dashboard)/deployments/actions.ts"
      via: "Server Action import"
      pattern: "deployTrainingJob"
    - from: "app/(dashboard)/deployments/actions.ts"
      to: "lib/db/schema.ts"
      via: "drizzle insert"
      pattern: "db.*insert.*deployments"
    - from: "lib/db/schema.ts"
      to: "trainingJobs"
      via: "foreign key reference"
      pattern: "references.*trainingJobs"
---

<objective>
Add deployments database schema, inference metrics simulator, and deploy Server Action with deploy button on completed training jobs.

Purpose: Establish the data layer and deploy action so users can create deployments from completed training jobs, which Plan 02 will display in a table with inference stats.
Output: Deployments table in DB, inference simulator service, deploy action, deploy button on job actions.
</objective>

<execution_context>
@/home/wraith/.claude/get-shit-done/workflows/execute-plan.md
@/home/wraith/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-deployments/06-RESEARCH.md
@lib/db/schema.ts
@lib/db/queries.ts
@app/(dashboard)/training/jobs/job-actions.tsx
@app/(dashboard)/training/jobs/actions.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add deployments schema, install dependencies, create inference simulator</name>
  <files>
    lib/db/schema.ts
    lib/services/inference-simulator.ts
    lib/db/queries.ts
  </files>
  <action>
  **1. Install dependencies:**
  ```bash
  pnpm add @tanstack/react-table
  npx shadcn@latest add table
  ```

  **2. Add deployments table to `lib/db/schema.ts`:**
  Add after `trainingMetrics` table:
  ```typescript
  export const deployments = pgTable("deployments", {
    id: serial("id").primaryKey(),
    jobId: integer("job_id").notNull().references(() => trainingJobs.id, { onDelete: "restrict" }),
    modelName: varchar("model_name", { length: 255 }).notNull(),
    version: varchar("version", { length: 50 }).notNull(),
    status: text("status", { enum: ["deploying", "active", "paused", "failed"] }).notNull().default("deploying"),
    endpoint: varchar("endpoint", { length: 500 }),
    createdAt: timestamp("created_at").defaultNow().notNull(),
    updatedAt: timestamp("updated_at").defaultNow().notNull().$onUpdate(() => new Date()),
  }, (table) => ({
    jobIdIdx: index("deployments_job_id_idx").on(table.jobId),
    statusIdx: index("deployments_status_idx").on(table.status),
  }))
  ```

  **3. Push schema to database:**
  ```bash
  pnpm db:push
  ```

  **4. Create inference simulator at `lib/services/inference-simulator.ts`:**
  Follow the research pattern exactly (Pattern 2 from 06-RESEARCH.md):
  - `InferenceMetrics` interface with: requestVolume, p50Latency, p95Latency, p99Latency, errorRate, successRate
  - `generateInferenceMetrics(deployment)` function (not a class — use a plain exported function)
  - Use Box-Muller transform for Gaussian noise
  - Base P50 latency: 50ms for nano models, 120ms for others
  - P95 = 2-4x P50, P99 = 1.5-2x P95
  - Request volume ramps with deployment age (maturity factor over 24h)
  - Error rate: 0.3% baseline with 5% chance of spike
  - Return zero metrics for non-active deployments
  - Use deployment `id` as seed for deterministic-ish behavior (use id in the Gaussian mean offset)

  **5. Add deployment queries to `lib/db/queries.ts`:**
  Add these cached queries:
  - `getAllDeployments()` — select all deployments ordered by createdAt desc
  - `getDeployment(id: number)` — select single deployment by id
  - `getDeploymentCounts()` — count by status (active, paused, failed, total)
  - `getDeploymentsByJobId(jobId: number)` — check if job already deployed

  Import `deployments` from schema, add necessary drizzle-orm imports.
  </action>
  <verify>
  - `pnpm build` passes (schema valid, imports correct)
  - `pnpm db:push` succeeds (deployments table created in Neon)
  - Verify `@tanstack/react-table` is in package.json dependencies
  - Verify `components/ui/table.tsx` exists (ShadCN table installed)
  </verify>
  <done>
  Deployments table exists in Neon database. Inference simulator generates realistic metrics. TanStack Table and ShadCN table component installed. Query functions exported from queries.ts.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create deploy Server Action and add deploy button to training jobs</name>
  <files>
    app/(dashboard)/deployments/actions.ts
    app/(dashboard)/training/jobs/job-actions.tsx
    app/(dashboard)/training/jobs/[id]/page.tsx
  </files>
  <action>
  **1. Create deploy Server Action at `app/(dashboard)/deployments/actions.ts`:**
  Follow the error-as-data pattern used throughout the project:
  ```typescript
  "use server"

  type ActionResult = { success: true; deploymentId: number } | { success: false; error: string }

  export async function deployTrainingJob(jobId: number): Promise<ActionResult>
  ```
  Implementation:
  - Validate job exists via db query (not cached — direct query for freshness)
  - Check `job.status === "complete"` — return error if not
  - Check if job already has an active deployment (query deployments by jobId where status = active) — return error "This job already has an active deployment" if so
  - Count existing deployments for this model name to generate version: `v1.{count}.0`
  - Insert deployment record with status "active" (skip deploying for demo)
  - Generate simulated endpoint: `/api/inference/${modelName-slug}/${version}`
  - `revalidatePath("/deployments")` and `revalidatePath("/training/jobs")` and `revalidatePath("/")`
  - Return `{ success: true, deploymentId }`
  - Wrap in try/catch, return error-as-data on failure

  **2. Update `app/(dashboard)/training/jobs/job-actions.tsx`:**
  Add a deploy button for completed jobs alongside the existing View button:
  - Import `deployTrainingJob` from `@/app/(dashboard)/deployments/actions`
  - Import `Rocket` from lucide-react
  - Import `useRouter` from `next/navigation` for redirect after deploy
  - For `job.status === "complete"`, render TWO buttons in a flex row:
    - Deploy button (Rocket icon, "Deploy") — calls deployTrainingJob, shows toast, redirects to `/deployments` on success
    - View button (Eye icon, "View") — existing link to job detail
  - Use `useTransition` for the deploy pending state (already exists in component)

  **3. Also add deploy button on the training monitor detail page** (`app/(dashboard)/training/jobs/[id]/page.tsx`):
  - Check if this is a Server Component (likely is) — if so, create a small client component `DeployButton` in the same `[id]/components/` folder
  - `DeployButton` takes `jobId: number` prop, handles the deploy action with toast + redirect
  - Show the deploy button only when `job.status === "complete"`
  - Place it near the job title/status area
  </action>
  <verify>
  - `pnpm build` passes
  - Manually test: navigate to training jobs list, find a "complete" job, deploy button appears
  - After clicking deploy, deployment record exists in database (check via Drizzle Studio: `pnpm db:studio`)
  - Toast notification appears on success/failure
  - Redirects to `/deployments` after successful deploy
  </verify>
  <done>
  Completed training jobs show a "Deploy" button in the jobs list and on the job detail page. Clicking deploy creates a deployment record in the database with auto-generated version and simulated endpoint. Error-as-data pattern returns meaningful errors for invalid states.
  </done>
</task>

</tasks>

<verification>
1. `pnpm build` passes with no TypeScript errors
2. Deployments table exists in Neon (verify via `pnpm db:studio`)
3. Deploy button visible on completed training jobs in the jobs list
4. Deploy button visible on completed training job detail/monitor page
5. Clicking deploy creates a record in the deployments table
6. Duplicate deploy (same job) returns an error toast
7. TanStack Table and ShadCN table component installed
</verification>

<success_criteria>
- Deployments schema is live in Neon database
- Inference simulator generates realistic metrics with proper distributions
- Users can deploy completed training jobs via button click
- Deploy action validates job status and prevents duplicate active deployments
- All existing functionality (training jobs, monitor) continues working
</success_criteria>

<output>
After completion, create `.planning/phases/06-deployments/06-01-SUMMARY.md`
</output>
